<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Happy Birthday!</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poiret+One&display=swap');

    body {
      margin: 0;
      height: 100vh;
      background:
        radial-gradient(ellipse at center, #0d0d1a 0%, #0b1020 80%),
        linear-gradient(135deg, #1a1a1a, #333);
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Poiret One', cursive, sans-serif;
      position: relative;
      color: #fff;
    }

    #stars {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: transparent;
      pointer-events: none;
      z-index: 0;
    }

    h1 {
      font-size: 4rem; /* Smaller font for mobile */
      position: relative;
      z-index: 10;
      text-align: center;
      user-select: none;
      padding: 0 1rem;
      color: hsl(0, 70%, 55%);
      animation: pulseGlow 2s infinite ease-in-out, colorFade 10s infinite linear, textBounce 2s infinite ease-in-out;
      text-shadow:
        0 0 5px rgba(255, 255, 255, 0.2),
        0 0 10px rgba(255, 255, 255, 0.15),
        0 0 15px rgba(255, 255, 255, 0.1);
    }

    @keyframes pulseGlow {
      0%, 100% {
        text-shadow:
          0 0 5px rgba(255, 255, 255, 0.2),
          0 0 10px rgba(255, 255, 255, 0.15),
          0 0 15px rgba(255, 255, 255, 0.1);
      }
      50% {
        text-shadow:
          0 0 8px rgba(255, 255, 255, 0.3),
          0 0 16px rgba(255, 255, 255, 0.2),
          0 0 25px rgba(255, 255, 255, 0.15);
      }
    }

    @keyframes colorFade {
      0% { color: hsl(0, 70%, 55%); }
      25% { color: hsl(90, 70%, 55%); }
      50% { color: hsl(180, 70%, 55%); }
      75% { color: hsl(270, 70%, 55%); }
      100% { color: hsl(360, 70%, 55%); }
    }

    @keyframes textBounce {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-10px);
      }
    }

    canvas#confetti {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 5;
      pointer-events: none;
    }

    /* Disable animations for reduced motion */
    @media (prefers-reduced-motion: reduce) {
      h1 {
        animation: none;
        text-shadow: none;
        color: hsl(0, 70%, 55%);
      }
    }

    /* Mobile-specific adjustments */
    @media (max-width: 600px) {
      h1 {
        font-size: 3rem;
      }
    }
  </style>
</head>
<body>
  <h1 role="heading" aria-label="Happy Birthday Celebration">ðŸŽ‰ Happy Birthday! ðŸŽ‚</h1>
  <canvas id="stars"></canvas>
  <canvas id="confetti"></canvas>

  <script>
    // Canvas support check
    const starCanvas = document.getElementById('stars');
    const confettiCanvas = document.getElementById('confetti');
    if (!starCanvas.getContext || !confettiCanvas.getContext) {
      document.body.innerHTML = '<h1 style="text-align: center;">ðŸŽ‰ Happy Birthday! ðŸŽ‚<br>(Canvas animations not supported)</h1>';
    } else {
      const starCtx = starCanvas.getContext('2d');
      let starWidth, starHeight;
      let stars = [];

      function createStars() {
        stars = [];
        const starCount = window.innerWidth < 600 ? 100 : 200; // Fewer stars on mobile
        for (let i = 0; i < starCount; i++) {
          stars.push({
            x: Math.random() * starWidth,
            y: Math.random() * starHeight,
            radius: Math.random() * 1.2,
            alpha: Math.random(),
            alphaChange: 0.005 + Math.random() * 0.015
          });
        }
      }

      function drawStars() {
        starCtx.clearRect(0, 0, starWidth, starHeight);
        stars.forEach(star => {
          star.alpha += star.alphaChange;
          if (star.alpha <= 0 || star.alpha >= 1) star.alphaChange *= -1;
          starCtx.beginPath();
          starCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
          starCtx.fillStyle = `rgba(255,255,255,${star.alpha.toFixed(2)})`;
          starCtx.fill();
        });
        requestAnimationFrame(drawStars);
      }

      function resizeCanvases() {
        starWidth = window.innerWidth;
        starHeight = window.innerHeight;
        starCanvas.width = starWidth;
        starCanvas.height = starHeight;
        confettiCanvas.width = window.innerWidth;
        confettiCanvas.height = window.innerHeight;
        createStars();
      }

      // Debounced resize
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(resizeCanvases, 100);
      });

      resizeCanvases();
      drawStars();

      const ctx = confettiCanvas.getContext('2d');
      const confettiColors = ['#ff3399', '#66ccff', '#ffff66', '#ccff66', '#ff9966', '#ff55aa', '#55ffcc', '#ffaa55'];

      class Confetti {
        constructor() {
          this.x = Math.random() * confettiCanvas.width;
          this.y = Math.random() * confettiCanvas.height;
          this.size = (Math.random() * 7) + 4;
          this.color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
          this.tilt = Math.random() * 10 - 5;
          this.tiltAngle = 0;
          this.tiltAngleIncrement = (Math.random() * 0.1) + 0.05;
          this.speedY = (Math.random() * 5) + 4;
          this.rotation = Math.random() * 360;
          this.rotationSpeed = (Math.random() - 0.5) * 8;
        }
        update() {
          this.y += this.speedY;
          this.tiltAngle += this.tiltAngleIncrement;
          this.tilt = Math.sin(this.tiltAngle) * 15;
          this.rotation += this.rotationSpeed;
          if (this.y > confettiCanvas.height + this.size) {
            this.x = Math.random() * confettiCanvas.width;
            this.y = -this.size;
            this.rotation = Math.random() * 360;
          }
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x + this.tilt, this.y);
          ctx.rotate(this.rotation * Math.PI / 180);
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size / 3);
          ctx.restore();
        }
      }

      const confettis = [];
      const confettiCount = window.innerWidth < 600 ? 50 : 75; // Fewer confetti on mobile
      for (let i = 0; i < confettiCount; i++) {
        confettis.push(new Confetti());
      }

      function animateConfetti() {
        ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        confettis.forEach(c => {
          c.update();
          c.draw(ctx);
        });
        requestAnimationFrame(animateConfetti);
      }

      animateConfetti();
    }
  </script>
</body>
</html>
